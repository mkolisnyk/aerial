---
title: Aerial Configuration Guide
layout: default
---

# Getting Started

[Aerial](/aerial) is designed to be extensible and to cover various input and output formats. Also, it may have different run options. In order to make processing more flexible and extensible for different areas there are some configuration capabilities. Mainly they include:

* General configuration options

* Source document parsing templates

* Scenario Generation Templates

Each of them is applied to different area and it is targeted to some specific part of the functionality.

# General Configuration Options

**Since version 0.0.4**

In order to make [Aerial](/aerial) working the direction it is expected there is a need to define some global settings which will be applied to core runner resources. Mainly it is related to the input/output format definition/customization or some common algorithm specifics or in general settings which can be used in multiple places in different point of Aerial processing life-cycle. All such parameters are stored in global configuration file.

During runtime all those values are stored in system properties.

By default Aerial uses internal resource with the configuration. It is stored under **/src/main/resources/aerial.properties** location. But Aerial functionality supports overriding it via: 

* [Command Line](/aerial/features#command-line)

* [Maven Plugin Configuration](/aerial/features#maven-plugin)

Currently the following properties are in use:

| Property | Category    | Description | Introduced In |
| -------- | ----------- | ----------- | ------------- |
| aerial.output.format | Input/output | Identifies template being used for [output generation](/aerial/configuration-guide#scenario-generation-templates) | [0.0.4](/aerial/releases#v004) |
| aerial.output.config | Input/output | Relevant to **aerial.output.format** property and it is used to point to custom template configuration in case **aerial.output.format** is set to **custom** | [0.0.4](/aerial/releases#v004) |
| aerial.input.format  | Input/output | Identifies the template being used for input formats parsing | [0.0.4](/aerial/releases#v004) |
| aerial.input.config  | Input/output | Used when **aerial.input.format** is set to **custom** and points to configuration file containing input format properties | [0.0.4](/aerial/releases#v004) |
| aerial.gen.nwise.size | Case Generators | Used by [Combinatorial Tests Optimization](/aerial/features#combinatorial-tests-optimization) algorithms and defines the size of the record which unique combinations we should check. 0 means **Exhaustive Testing** | [0.0.4](/aerial/releases#v004) |
| aerial.types.date.default | Data Types | Used for date values generation and defines the date format which is supposed to be used by default | [0.0.4](/aerial/releases#v004) |
| aerial.types.custom.classes | Data Types | Defines the colon separated list of classes to be used for custom types | [0.0.5](/aerial/releases#v005) |

# Source document parsing templates

**Since version 0.0.4**

The default input document format is pretty generic and it doesn't include such simple things as formatting. Additionally, the set of keywords being used to indicate each specific block also can be different depending on input source and common requirements definition style. In order to adapt [Aerial](http://mkolisnyk.github.io/aerial) to such input format variations there was input format configuration designed.

## Template Items Description

Templates are defined in specific property files. There is a bunch of built-in templates located at **src/main/resources/input** location. Also, [Aerial](/aerial) provides functionality to define custom format in case we need to output generated content is some specific way.

All configuration properties are defined in the specific format:

{% highlight bat linenos=table %}
aerial.<Format Name>.<Property Name>
{% endhighlight %}

Where:

* **Format Name** is the general name of the format to use. It is the name which is specified while defining which format we want to use

* **Property Name** is the suffix which uniquely identifies property to set.

Here is the list of acceptable suffixes:

| Property Suffix Name       | Description |
| -------------------------- | ----------- |
| token.action               | Indicates start of the actions block |
| token.prerequisites        | Indicates pre-requisites block |
| token.input                | Indicates input block |
| token.valid_output         | Indicates block of actions on valid input |
| token.error_output         | Indicates block of actions on invalid input |
| token.feature              | Indicates feature block |
| token.case                 | Indicates case block |
| token.additional_scenarios | Indicates block for additional scenarios |

## Example

Here is an example of the properties file for the default input document template:

{% highlight properties linenos=table %}
aerial.plain.token.action=Action:
aerial.plain.token.prerequisites=Pre-requisites:
aerial.plain.token.input=Input:
aerial.plain.token.valid_output=On Success:
aerial.plain.token.error_output=On Failure:
aerial.plain.token.feature=Feature:
aerial.plain.token.case=Case:
aerial.plain.token.additional_scenarios=Additional Scenarios:
{% endhighlight %}

# Scenario Generation Templates

**Since version 0.0.3**

[Aerial](/aerial) is targeted to generate test scenarios applicable to different engines. That can be some BDD engines like [Cucumber](http://cukes.info) or [JBehave](http://jbehave.org). Also it can be any other format. Main thing is that there are some data items which are generated by the engine as well as there are items which do not depend on generation algorithms and rather designed for formatted representation of data generated. So, mainly each specific file output format is defined by specific output formatting templates.

## Template items description

Such templates are defined in specific property files. There is a bunch of built-in templates located at **src/main/resources/generator** location. Also, [Aerial](/aerial) provides functionality to define custom format in case we need to output generated content is some specific way.

All configuration properties are defined in the specific format:

{% highlight bat linenos=table %}
aerial.<Format Name>.<Property Name>
{% endhighlight %}

Where:

* **Format Name** is the general name of the format to use. It is the name which is specified while defining which format we want to use

* **Property Name** is the suffix which uniquely identifies property to set.

Here is the list of acceptable suffixes with insertion patterns:

| Property Suffix Name | Description | Macro insertions |
| -------------------- | ----------- | ---------------- |
| feature | Defines the format for entire feature | <ul><li>{NAME} - place holder for feature name <li>{CASES} - place holder for generated test scenarios <li>{ADDITIONAL_SCENARIOS} - place holder for additional scenarios insertion |
| case | Defines the format for specific scenario | <ul><li>{NAME} - place holder for test scenario name <li>{BODY} - place holder for the scenario body <li>{DATA} - place holder for test data to insert |
| action | Defines the format for main actions to perform | {ACTION} - the actual text of action |
| prerequisite | Defines the format for pre-condition actions | {CONTENT} - place holder for the pre-condition content |
| output.valid | Defines the format for verification steps which are used when we expect correct behaviour | {CONTENT} - place holder for the content |
| output.error | Defines the format for verification steps which are used when we expect some errors | {CONTENT} - place holder for the content |
| additional_scenarios | Defines general pattern for additional scenarios insertion | {CONTENT} - place holder for the additional scenario content |
| data.header | A part of complex data structures input. It defines general structure of header given that header content is passed as single value | {TITLES} - place holder for the header text insertion |
| data.header.delimiter | Defines the delimiter between each header item | N/A |
| data.row | A part of complex data structures input. It defines general structure of data row given that data rows content is passed as single value | {TITLES} - place holder for the data row text insertion |
| data.row.delimiter | Defines the delimiter between each data row item | N/A |
| data.field | Defines the pattern which is used to inject some variables into the generated instructions | {NAME} - place holder for the field name |
| data.field.modified_prefix | Defines the format of auxiliary variable which may be used in the scenarios requiring alternative value (e.g. [Unique value scenarios generation](/aerial/features#unique-value-scenarios)) | N/A |

## Example

The example below shows the configuration for [Cucumber](http://cukes.info) scenarios generation:

{% highlight properties linenos=table %}
aerial.cucumber.feature=Feature: {NAME}\r\n\
{CASES}\
{ADDITIONAL_SCENARIOS}
aerial.cucumber.case=\tScenario Outline: {NAME}\r\n\
{BODY}\
\tExamples:\r\n\
{DATA}\r\n
aerial.cucumber.action=\t\tWhen {ACTION}\r\n
aerial.cucumber.prerequisite=\t\tGiven {CONTENT}
aerial.cucumber.output.valid=\t\tThen {CONTENT}\r\n
aerial.cucumber.output.error=\t\tThen {CONTENT}\r\n
aerial.cucumber.additional_scenarios=\
{CONTENT}
aerial.cucumber.data.header=\t\t| {TITLES} |\r\n
aerial.cucumber.data.header.delimiter=\ | 
aerial.cucumber.data.row=\t\t| {DATA} |\r\n
aerial.cucumber.data.row.delimiter=\ | 
aerial.cucumber.data.field=<{NAME}>
aerial.cucumber.data.field.modified_prefix=Modified 
{% endhighlight %}
