---
title: Aerial Configuration Guide
layout: default
---

# Getting Started

[Aerial](/aerial) is designed to be extensible and to cover various input and output formats. Also, it may have different run options. In order to make processing more flexible and extensible for different areas there are some configuration capabilities. Mainly they include:

* General configuration options

* Source document parsing templates

* Scenario Generation Templates

Each of them is applied to different area and it is targeted to some specific part of the functionality.

# Scenario Generation Templates

[Aerial](/aerial) is targeted to generate test scenarios applicable to different engines. That can be some BDD engines like [Cucumber](http://cukes.info) or [JBehave](http://jbehave.org). Also it can be any other format. Main thing is that there are some data items which are generated by the engine as well as there are items which do not depend on generation algorithms and rather designed for formatted representation of data generated. So, mainly each specific file output format is defined by specific output formatting templates.

## Template items description

Such templates are defined in specific property files. There is a bunch of built-in templates located at **src/main/resources/generator** location. Also, [Aerial](/aerial) provides functionality to define custom format in case we need to output generated content is some specific way.

All configuration properties are defined in the specific format:

{% highlight bat linenos=table %}
aerial.&lt;Format Name&gt;.&lt;Property Name&gt;
{% endhighlight %}

Where:

* **Format Name** is the general name of the format to use. It is the name which is specified while defining which format we want to use

* **Property Name** is the suffix which uniquely identifies property to set.

Here is the list of acceptable suffixes with insertion patterns:

<table>
<tr><th>Property Suffix Name</th><th>Description</th><th>Macro insertions</th></tr>
<tr><td>feature</td><td>Defines the format for entire feature</td>
	<td>
	<ul>
	<li>{NAME} - place holder for feature name
	<li>{CASES} - place holder for generated test scenarios
	<li>{ADDITIONAL_SCENARIOS} - place holder for additional scenarios insertion
	</ul>
	</td>
</tr>
<tr><td>case</td><td>Defines the format for specific scenario</td>
	<td>
	<ul>
	<li>{NAME} - place holder for test scenario name
	<li>{BODY} - place holder for the scenario body
	<li>{DATA} - place holder for test data to insert
	</td>
</tr>
<tr><td>action</td><td>Defines the format for main actions to perform</td>
	<td>
	<ul>
	<li> {ACTION} - the actual text of action
	</ul>
	</td>
</tr>
<tr><td>prerequisite</td><td>Defines the format for pre-condition actions</td>
	<td>
	<ul>
	<li> {CONTENT} - place holder for the pre-condition content
	</ul>
	</td>
</tr>
<tr><td>output.valid</td><td>Defines the format for verification steps which are used when we expect correct behaviour</td>
	<td>
	<ul>
	<li> {CONTENT} - place holder for the content
	</ul>
	</td>
</tr>
<tr><td>output.error</td><td>Defines the format for verification steps which are used when we expect some errors</td>
	<td>
	<ul>
	<li> {CONTENT} - place holder for the content
	</ul>
	</td>
</tr>
<tr><td>additional_scenarios</td><td>Defines general pattern for additional scenarios insertion</td>
	<td>
	<ul>
	<li> {CONTENT} - place holder for the additional scenario content
	</ul>
	</td>
</tr>
<tr><td>data.header</td><td>A part of complex data structures input. It defines general structure of header given that header content is passed as single value</td>
	<td>
	{TITLES} - place holder for the header text insertion
	</td>
</tr>
<tr><td>data.header.delimiter</td><td>Defines the delimiter between each header item</td>
	<td>N/A</td>
</tr>
<tr><td>data.row</td><td>A part of complex data structures input. It defines general structure of data row given that data rows content is passed as single value</td>
	<td>{TITLES} - place holder for the data row text insertion</td>
</tr>
<tr><td>data.row.delimiter</td><td>Defines the delimiter between each data row item</td>
	<td>N/A</td>
</tr>
<tr><td>data.field</td><td>Defines the pattern which is used to inject some variables into the generated instructions</td>
	<td>{NAME} - place holder for the field name</td>
</tr>
<tr><td>data.field.modified_prefix</td><td>Defines the format of auxiliary variable which may be used in the scenarios requiring alternative value (e.g. [Unique value scenarios generation](/aerial/features#unique-value-scenarios))</td>
	<td>N/A</td>
</tr>
</table>


<h2>Example</h2>

The example below shows the configuration for [Cucumber](http://cukes.info) scenarios generation:

{% highlight properties linenos=table %}
aerial.cucumber.feature=Feature: {NAME}\r\n\
{CASES}\
{ADDITIONAL_SCENARIOS}
aerial.cucumber.case=\tScenario Outline: {NAME}\r\n\
{BODY}\
\tExamples:\r\n\
{DATA}\r\n
aerial.cucumber.action=\t\tWhen {ACTION}\r\n
aerial.cucumber.prerequisite=\t\tGiven {CONTENT}
aerial.cucumber.output.valid=\t\tThen {CONTENT}\r\n
aerial.cucumber.output.error=\t\tThen {CONTENT}\r\n
aerial.cucumber.additional_scenarios=\
{CONTENT}
aerial.cucumber.data.header=\t\t| {TITLES} |\r\n
aerial.cucumber.data.header.delimiter=\ | 
aerial.cucumber.data.row=\t\t| {DATA} |\r\n
aerial.cucumber.data.row.delimiter=\ | 
aerial.cucumber.data.field=<{NAME}>
aerial.cucumber.data.field.modified_prefix=Modified 
{% endhighlight %}