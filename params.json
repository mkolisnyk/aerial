{"name":"Aerial","tagline":"Executable Requirements are now really executable","body":"Aerial\r\n======\r\n\r\n**Aerial** is an engine implementing the approach of **Executable Requirements**. Mainly it is designed as an extension of **Cucumber** to provide the following possibilities:\r\n* **More compact and structured representation of requirements and scenarios** - actually text instructions are targeted to look more like requirements or technical specifications rather than scenarios\r\n* **Built-in mechanism for generating test scenarios** - main idea is that test scenarios are generated based on formal description of some feature and it's attributes. This minimises efforts on test data definition and data preparation. You just have to specify what is the data and how each data item is relevant to each other\r\n* **Generalised approach for getting data from external resources** - requirements can be stored in any form and in any place (or system). The **Aerial** should provide extensible mechanism to retrieve requirements from various different data sources \r\n* **Ability to perform static checks on requirements** - since we expand requirements into tests using some rules there's an ability to find out requirement inconsistencies during initial processing stage\r\n* **Tests and their automated implementation reacts on any requirement change** - most of test management systems simply store dedicated records for requirements, tests and automated tests. But they are just linked by abstract DB structure. Thus, if we do any modification into one of those items others wouldn't be reflected. Since **Aerial** generates tests and automated tests based on requirements as an input, any change to requirements will be immediately reflected. So, tests always correspond to requirements.\r\n* **Simplify requirements and test coverage calculation** - mainly such coverage is 100% by design\r\n\r\nWhy using Aerial?\r\n======\r\n\r\nAll the time when we design test scenarios we have a lot of typical and \"routine\" checks actions to perform and checkpoints to make. E.g. any time we encounter field containing an e-mail we should check:\r\n* Value matching e-mail format ( <addredd name>@<company/organization>.<domain> )\r\n* Value containing multiple @ characters\r\n* Empty value\r\n* Simple text value\r\n* Spaces in the address\r\n* Special characters in the address (E.g. multiple dots are acceptable in e-mail address)\r\nFor other data types there would be different checks depending on the data structure. \r\n\r\nMain thing is that in most cases we have to do typical cases for all those data. So, in such cases it's enough just to define the data structure and the flow to use in each specific case. Thus we'll get declarative representation of the business function which (representation) can be used for tests generation.\r\nThus, we'll have to use declarative representation of the functionality to test which looks pretty similar to requirements and technical specification. As the result, we have an ability to combine requirements, tests and their automated implementation within common resource. So, in this structure our tests are generated based on requirements and auto-tests are generated based on tests.\r\n\r\nWhat does it give to us? Main benefits:\r\n* We always sure requirements are linked to tests. Just by design.\r\n* If we want to change requirements our tests will be changed as well, so we never care if our tests are in sync with requirements\r\n* Since the system is targeted to generate test scenarios based on formal description we get an advantage it writing efforts as a lot of routine actions are simply generated. Thus, we minimise human factor on such tasks. \r\n\r\nHow does it work? \r\n======\r\n\r\nThe engine is designed to generate [Cucumber](http://cukes.info) features based on specific document description. After generation is done it triggers Cucumber run the same way as we do for any other tests of that kind.\r\n\r\nExample\r\n-------\r\n\r\nMain source for generation is the document. It defines rules to generate feature file. Here is an example of it:\r\n\r\n**src/test/resources/SampleDocument.document**:\r\n\r\n```\r\nThis is a sample document\r\nWith multiline description\r\n\r\nFeature: Sample Feature\r\n    This is a sample feature\r\n    With multiline description\r\n\r\n    Case: Sample Test\r\n        This is a sample test case\r\n        With multiline description\r\n\r\n        Action:\r\n            Sample action\r\n        Input:\r\n            | Name | Type | Value   |\r\n            | Test | Int  | [0;100) |\r\n        On Success:\r\n            This is what we see on success\r\n        On Failure:\r\n            This is what we see on error\r\n        Pre-requisites:\r\n            These are our pre-requisites\r\n    Additional Scenarios:\r\n    Scenario: Sample Scenario 1\r\n\r\n```\r\n\r\nThen we define the test class which should be the runner for the above document description:\r\n\r\n**src/test/java/com/sample/aerial/AerialSampleClass.java**:\r\n\r\n``` java\r\npackage com.sample.aerial;\r\n\r\nimport com.github.mkolisnyk.aerial.annotations.Aerial;\r\nimport com.github.mkolisnyk.aerial.annotations.AerialAfterSuite;\r\nimport com.github.mkolisnyk.aerial.annotations.AerialBeforeSuite;\r\nimport com.github.mkolisnyk.aerial.core.AerialRunner;\r\nimport com.github.mkolisnyk.aerial.core.params.AerialSourceType;\r\n\r\nimport cucumber.api.CucumberOptions;\r\n\r\n@CucumberOptions(\r\n        format = {\"html:target/cucumber-html-report\",\r\n                  \"json:target/cucumber.json\",\r\n                  \"pretty:target/cucumber-pretty.txt\",\r\n                  \"usage:target/cucumber-usage.json\"\r\n                 },\r\n        features = {\"output/\" },\r\n        glue = {\"com/github/mkolisnyk/aerial\" },\r\n        tags = { }\r\n)\r\n@Aerial(\r\n        inputType = AerialSourceType.FILE,\r\n        source = \"src/test/resources\",\r\n        additionalParams = { \"\" },\r\n        destination = \"output/\")\r\n@RunWith(AerialRunner.class)\r\npublic class AerialSampleClass {\r\n}\r\n```\r\n\r\nIt's empty class but most of the parameters are defined in annotations:\r\n* **@CucumberOptions** - on the back it's Cucumber tests so the configuration parameters. This is Cucumber annotation and the parameters can be see on the [GitHub Source](https://github.com/cucumber/cucumber-jvm/blob/master/core/src/main/java/cucumber/api/CucumberOptions.java).\r\n  Main items we are interested in are:\r\n  * **features** - we should make sure that Aerial outputs generated features to the same folder so that Cucumber will pick them up and execute\r\n  * **glue** - we should have reserved location where our glue code is stored\r\n* **@Aerial** - main annotation for Aerial engine generation. Mainly it defines the source and the destination of the generated content. We should make sure that **destination** parameter of this annotation points to the same location as **features** option in the **@CucumberOptions** definition.\r\n* **@RunWith(AerialRunner.class)** - this will drive all the magic. Initially it runs features generation and then it runs Cucumber.\r\n\r\nThen we prepare Java glue code for text instructions binding:\r\n\r\n**src/test/java/com/sample/aerial/AerialGluCode.java**:\r\n\r\n``` java\r\npackage com.sample.aerial;\r\n\r\nimport cucumber.api.java.en.Given;\r\nimport cucumber.api.java.en.Then;\r\nimport cucumber.api.java.en.When;\r\n\r\npublic class AerialGluCode {\r\n\r\n    @Given(\"^These are our pre-requisites$\")\r\n    public void theseAreOurPreRequisites() throws Throwable {\r\n    }\r\n\r\n    @When(\"^Sample action$\")\r\n    public void sampleAction() throws Throwable {\r\n    }\r\n\r\n    @Then(\"^This is what we see on success$\")\r\n    public void thisIsWhatWeSeeOnSuccess() throws Throwable {\r\n    }\r\n\r\n    @Then(\"^This is what we see on error$\")\r\n    public void thisIsWhatWeSeeOnError() throws Throwable {\r\n    }\r\n}\r\n```\r\n\r\nAfter that we can run our test as ordinary JUnit test. On the background it will be executed via **Cucumber** runner.\r\n\r\nFeatures\r\n======\r\n\r\nUser Reference Guide\r\n======\r\n\r\nReleases\r\n======\r\n\r\nDocumentation\r\n======\r\n\r\nBlog Posts & Live Demos\r\n======\r\n\r\n[Blog: Test Automation From Inside](http://mkolisnyk.blogspot.com)\r\n\r\nAuthors\r\n======\r\nMyk Kolisnyk (kolesnik.nickolay@gmail.com) \r\n\r\n<a href=\"http://ua.linkedin.com/pub/mykola-kolisnyk/14/533/903\"><img src=\"http://www.linkedin.com/img/webpromo/btn_profile_bluetxt_80x15.png\" width=\"80\" height=\"15\" border=\"0\" alt=\"View Mykola Kolisnyk's profile on LinkedIn\"></a>\r\n<a href=\"http://plus.google.com/108480514086204589709?prsrc=3\" rel=\"publisher\" style=\"text-decoration:none;\">\r\n<img src=\"http://ssl.gstatic.com/images/icons/gplus-16.png\" alt=\"Google+\" style=\"border:0;width:16px;height:16px;\"/></a>\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}