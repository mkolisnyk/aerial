---
title: Features
layout: default
---

# Run Options

## Command Line

## Maven Plugin

[![Aerial Maven Plugin](https://maven-badges.herokuapp.com/maven-central/com.github.mkolisnyk/aerial-maven-plugin/badge.svg?style=flat)](http://mvnrepository.com/artifact/com.github.mkolisnyk/aerial-maven-plugin)

Since 0.0.2 version the Aerial is provided not only as the library or command line utility but also as the Maven plugin which is bound to **generate-sources** phase. Main goal implementing generation is **aerial:generate**.
More information can be found on [project documentation pages](http://mkolisnyk.github.io/aerial/aerial-maven-plugin-0.0.2/).

## Library

# Input Sources Supported

## String

## File

## JIRA

**Since version 0.0.2**

In some cases initial requirements may be stored somewhere in tracking systems like Jira. E.g. we can use some specific issue type and all specifications are placed in the description field.
In this case we should be able to retrieve them the same way as from multiple files. For this purpose we can use **JIRA** as an input source.

Here is the Maven example on how to set Jira as an input source:
{% highlight xml linenos=table %}
<project>
  ...
  <build>
    <plugins>
      <plugin>
        <groupId>com.mkolisnyk.github</groupId>
        <artifactId>aerial-maven-plugin</artifactId>
        <version>0.0.2</version>
        <configuration>
            <inputType>JIRA</inputType>
            <source>http://localhost:8080/jira</source>
            <outputType>FILE</outputType>
            <destination>output/</destination>
            <namedParams>
                <user>some_user</user>
                <password>some_password</password>
                <field>description</field>
            </namedParams>
            <valueParams>
                <param>project=Wallboards AND status=Open</param>
            </valueParams>
        </configuration>
      </plugin>
      ...
    </plugins>
  </build>
  ...
</project>
{% endhighlight %}

More detailed description of the above example can be found [here](http://mkolisnyk.github.io/aerial/aerial-maven-plugin-0.0.2/usage.html#Generating_Features_Based_on_JIRA_Content_Example).

# Scenarios Generated

Aerial uses document in specific format to generate scenarios. Each document contains specific sections and generally can be represented with the following structure: 

{% highlight bat linenos=table %}
< Entire document description >

Feature: < Feature Name >
    < Feature description >

    Case: < Case Name >
        < Case Description >

        Action:
            < Action text >
        Input:
            < Input Data Table >
        On Success:
            < Actions in case of success >
        On Failure:
            < Actions in case of error >
        Pre-requisites:
            < Pre-requisites steps >
    Additional Scenarios:
        < Explicitly defined custom Cucumber scenarios >
{% endhighlight %}

Mainly it generates several sets of scenarios based on input data given.
They are:

* **Positive Scenarios** - scenarios operating with valid data and expecting valid output

* **Negative Scenarios** - scenarios operating with incorrect data expecting error output

* **Unique Value Scenarios** - scenarios which are targeted to make sure that some value cannot be used more than once within the same scenario

Depending on scenario type different sections are used in different combinations.
The below paragraphs contain more detailed description of each scenario generation.

## Custom

**Since version 0.0.4**

Additionally Aerial has functionality to load and process custom classes defined outside of the box. For this purpose there is reserved **CUSTOM** keyword for input type. This is specific feature for better extensibility and customization without changing the core engine. More details on configuration and extensions development see the [Extensions Development Guide: Custom Input Readers](/aerial/extensions-dev-guide#custom-input-readers) chapter.

# Positive Scenarios

Positive scenarios operate with positive values and they are targeted to check expected behaviour. Mainly positive scenarios are generated from document description using the following structure:

{% highlight bat linenos=table %}
    Scenario: < Case Name > positive test
        Given < Pre-requisites steps >
        When < Action text >
        Then < Actions in case of success >
    Examples:
        <The positive test data table>
{% endhighlight %}

## Combinatorial tests optimization

**Since version 0.0.3**

In order to decrease the number of test scenarios to be performed positive test scenarios are additionally optimized using [combinatorial](http://pairwise.org/) methods. It means that is we have some set of valid input values the entire test data would contain not just all possible combinations but it should cover all possible combinations of N parameters (by default N equals 2 which leads to pair-wise testing). It is done to decrease the number of tests to be performed. In worst case the number of tests is the same as for all possible combinations. But normally, if N is less than number of fields the number of tests is smaller.

Main idea behind that approach is that potentially error is caused when we process some combination of N parameters. The smaller N is the bigger optimization we have. E.g. If we have total number of fields equal 10 and we look for any records where each value is present at least once (N = 1) the number of tests to perform is the biggest number of values among all 10 fields.

# Negative Scenarios

Negative scenarios are built the same way as positive scenarios except they operate with negative test data where at least one item doesn't fit acceptable format. Also, since this scenario uses 
invalid input it expects actions on errors to be expected results. So, mainly negative test scenario is build using the following template:

{% highlight bat linenos=table %}
    Scenario: < Case Name > negative test
        Given < Pre-requisites steps >
        When < Action text >
        Then < Actions in case of error >
    Examples:
        <The negative test data table>
{% endhighlight %}

# Unique Value Scenarios

Unique value scenario generation is triggered as soon as at least one field has **Unique** column value set to **true** in the input data table.
In this context the **Unique** term isn't restricted just with the case when we cannot create 2 records with the same value of some field. In this case uniqueness means
that we cannot perform some action twice having the same value for some field.

Getting to the technical side of the scenario generation we should get the scenario when we run action successfully at first turn but on the second turn we get the error if we use the same value in some field.
Thus, the unique value scenario can be described with the following template:
{% highlight bat linenos=table %}
    Scenario: < Case Name > negative test
        Given < Pre-requisites steps >
        When < Action text >
        Then < Actions in case of success >
        When < Action text >
        Then < Actions in case of error >
    Examples:
        <Unique scenario data>
{% endhighlight %}

# Data Types Supported

# Int

# Date

# String

# Enums

**Since version 0.0.3**

In some cases we have pre-defined set of input values and this list is fixed. Thus, the potential list of input parameters is limited with the list of specific values. In order to handle this the Enum data type was introduced.

Here is an example of Enum type definition in the [Input](/aerial/user-guide#input) section:

{% highlight bat linenos=table %}
Input:
    | Name   | Type | Value                       |
    | Season | enum | Winter;Spring;Summer;Autumn |
{% endhighlight %}

All constant values are split with **;** (semi-colon) delimiter. If for any reason we need to include it into some enumerated string we can escape it with back-slash. E.g.:

{% highlight bat linenos=table %}
Input:
    | Name   | Type | Value                       |
    | Season | enum | Win\;ter;Spring;Summer;Autumn |
{% endhighlight %}

This way the first enum value would be **Win;ter**.

When test data is generated based on this type it generates 2 set of values:

* Positive - contains every single value which belongs to the enum

* Negative - contains value which doesn't belong to enum