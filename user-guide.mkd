---
title: Aerial User Guide
layout: default
---

# Getting Started

All Aerial transformation is mainly done in 4 steps:

1. Include dependency

2. Create requirements document

3. Configure Cucumber code generation

4. Run JUnit test

# Including Aerial as Dependency

Aerial is provided as Maven dependency and can be included using the construction like:

{% highlight xml linenos=table %}
<dependency>
	<groupId>com.github.mkolisnyk</groupId>
	<artifactId>aerial</artifactId>
	<version>0.0.1</version>
</dependency>
{% endhighlight %}

or for Gradle:

{% highlight groovy linenos=table %}
'com.github.mkolisnyk:aerial:0.0.1'
{% endhighlight %}

# Document Structure

Each Aerial document has the structure like:

{% highlight bat linenos=table %}
< Entire document description >

Feature: < Feature Name >
    < Feature description >

    Case: < Case Name >
        < Case Description >

        Action:
            < Action text >
        Input:
            < Input Data Table >
        On Success:
            < Actions in case of success >
        On Failure:
            < Actions in case of error >
        Pre-requisites:
            < Pre-requisites steps >
    Additional Scenarios:
        < Explicitly defined custom Cucumber scenarios >
{% endhighlight %}

## Feature Section

| **Description** | Topmost section of the document. Groups multiple cases and scenarios. Directly maps to Cucumber features during generation |
| **Parent Section** | Entire Document |
| **Multiple Entries** | Yes |
| **Mandatory** | No |
| **If Not Specified** | If not defined only document description is allowed |

## Case Section

| **Description** | Contains specific case within the feature. Maps to group of Cucumber scenarios |
| **Parent Section** | Feature |
| **Multiple Entries** | Yes |
| **Mandatory** | No |
| **If Not Specified** | If not specified the **Additional Scenarios** section is allowed |

### Pre-requisites

| **Description** | Contains test scenario pre-conditions. Belongs to each specific **Case Section**. |
| **Parent Section** | Case |
| **Multiple Entries** | No |
| **Mandatory** | No |
| **If Not Specified** | If empty, no pre-conditions are defined |

### Action

| **Description** | Contains instructions responsible for main scenario actions before verification section |
| **Parent Section** | Case |
| **Multiple Entries** | No |
| **Mandatory** | Yes |
| **If Not Specified** | The validation will fail |

### Input

| **Description** | Contains the table of input value descriptions being used within specific case for Action, On Success, On Failure and Pre-Requisites sections |
| **Parent Section** | Case |
| **Multiple Entries** | No |
| **Mandatory** | Yes |
| **If Not Specified** | The validation will fail |

### On Success

| **Description** | Contains the set of instructions to be used in case of positive test scenarios |
| **Parent Section** | Case |
| **Multiple Entries** | No |
| **Mandatory** | Yes |
| **If Not Specified** | The validation will fail |

### On Failure

| **Description** | Contains the set of instructions to be used in case of negative test scenarios |
| **Parent Section** | Case |
| **Multiple Entries** | No |
| **Mandatory** | Yes |
| **If Not Specified** | The validation will fail |

## Additional Scenarios

| **Description** | Contains plain Cucumber scenarios to be used in addition to scenarios generated from data in **Case** section |
| **Parent Section** | Feature |
| **Multiple Entries** | Yes |
| **Mandatory** | No |
| **If Not Specified** | Only generated scenarios will be used |

# Input Data Description

Input data is specific section which contains input values definitions with the rules how they should be validated. This section is core part of data generation. Here is some example of input section:

{% highlight bat linenos=table %}
Input:
    | Name | Type | Value   |
    | Test | Int  | [0;100) |
{% endhighlight %}

This section defines single integer parameter named **Test** which acceptable values are from 0 (inclusively) to 100 (exclusively). So, Aerial will generate scenarios for different inputs for this parameter.

## Input Section Structure

Input section is represented as the table with the following columns:

| Column Name | Description |
| ----------- | ----------- |
| Name        | Contains the name of the field |
| Type        | Defines the type of the field. The test data will be generated based on the input type |
| Value       | Identifies rule the current field should meet in order to be of acceptable value |
| Condition   | Identifies boolean condition when the Value is applied |
| Unique      | Flag identifying whether the value of this field should be unique in this scenario. This is needed for specific scenario generation |

## Data Types in Use and Acceptable Value Patterns

The most complicated and important part of this table is supported data types and value pattern to be used for generation. Currently the following data types are supported:

* Int - numeric value

* Date - any formatted date

* String - text string

Depending on data type we should use appropriate patterns.

### Numeric Value Patterns

| Pattern | Description | Example |
| ------- | ----------- | ------- |
| &lt;Any explicit value&gt; | Explicitly defined value. It means that this field can accept only value like this | 9 |
| **[A;B]** or **[A;B)** or **(A;B]** or **(A;B)** | Range value patterns. Depending on bracket types the range can include or exclude corner value. Square bracket indicates inclusive range while round bracket excludes corner value | [0, 10) |

### Date Value Patterns

| Pattern | Description | Example |
| ------- | ----------- | ------- |
| &lt;single date pattern&gt; | Uses explicit date pattern for single date. For test data generation purpose there would be current date used | dd-MM-yyyy |
| [A;B], Format: &lt; Date Format &gt;| Format which accepts date range from start to end point. Depending on bracket type the range can be exclusive or inclusive. The range values should have the same format as it's defined after the **Format** keyword | [01-01-2000;02-10-2010), Format: dd-MM-yyyy |

### String Value Patterns

Usually string acceptable value rules are defined using regular expression. It means that text value should match some specific regular expression pattern. 

# Input/Output Sources

## Input Sources

| Source | Description | Parameters Specified |
| ------ | ----------- | -------------------- |
| **File** | Indicates that input Aerial document is read from file system | Root directory where to take files from. Additionally files can be specified by mask to filter out unnecessary documents |  

## Output Sources

| Source | Description | Parameters Specified |
| ------ | ----------- | -------------------- |
| **File** | Indicates that generated Cucumber features are written into text files. This is the main output type as it is targeted to Cucumber which mainly supports files | |

# Java Annotations

## @Aerial

Main annotation identifying Aerial generation attributes. This annotation is set for test class which should be JUnit runnable. So, initially the class should look like:

{% highlight java linenos=table %}
package com.github.mkolisnyk.aerial;

import org.junit.runner.RunWith;

import com.github.mkolisnyk.aerial.annotations.Aerial;
import com.github.mkolisnyk.aerial.core.AerialRunner;
import com.github.mkolisnyk.aerial.core.params.AerialSourceType;

import cucumber.api.CucumberOptions;

@RunWith(AerialRunner.class)
public class AerialRunnerTest {
}
{% endhighlight %}

Thus, we target JUnit to run tests using **AerialRunner** class which will drive Cucumber features generation with further Cucumber run.
After that we're ready to add @Aerial annotation. Here is an example of generator configuration targeted to read requirement documents from files located in the **src/test/resources** folder and write generated files into **./output/** folder:

{% highlight java linenos=table %}
package com.github.mkolisnyk.aerial;

import org.junit.runner.RunWith;
import com.github.mkolisnyk.aerial.annotations.Aerial;
import com.github.mkolisnyk.aerial.core.AerialRunner;
import com.github.mkolisnyk.aerial.core.params.AerialSourceType;
import cucumber.api.CucumberOptions;

@Aerial(
    inputType = AerialSourceType.FILE,
    source = "src/test/resources",
    additionalParams = { "" },
    destination = "output/")
@RunWith(AerialRunner.class)
public class AerialRunnerTest {
}
{% endhighlight %}

The last part is to add **CucumberOptions** annotation to point Cucumber where to take the input from:
{% highlight java linenos=table %}
package com.github.mkolisnyk.aerial;

import org.junit.runner.RunWith;
import com.github.mkolisnyk.aerial.annotations.Aerial;
import com.github.mkolisnyk.aerial.core.AerialRunner;
import com.github.mkolisnyk.aerial.core.params.AerialSourceType;
import cucumber.api.CucumberOptions;

@CucumberOptions(
        format = {"html:target/cucumber-html-report",
                  "json:target/cucumber.json",
                  "pretty:target/cucumber-pretty.txt",
                  "usage:target/cucumber-usage.json"
                 },
        features = {"output/" },
        glue = {"com/github/mkolisnyk/aerial" },
        tags = { }
)
@Aerial(
    inputType = AerialSourceType.FILE,
    source = "src/test/resources",
    additionalParams = { "" },
    destination = "output/")
@RunWith(AerialRunner.class)
public class AerialRunnerTest {
}
{% endhighlight %}

## @AerialBeforeSuite and @AerialAfterSuite

As it was mentioned before the AerialRunner is wrapper on Cucumber JUnit runner class. So, all annotations applicable to Cucumber runner are applicable there. But there may be a need to perform some actions before and/or after any code generation or tests execution.
For this purpose there're dedicated annotations named @AerialBeforeSuite and @AerialAfterSuite correspondingly. They are assigned to methods which are supposed to be executed before and after entire suite run. With these annotations the above example can be appended like this:

{% highlight java linenos=table %}
package com.github.mkolisnyk.aerial;

import org.junit.runner.RunWith;
import com.github.mkolisnyk.aerial.annotations.Aerial;
import com.github.mkolisnyk.aerial.core.AerialRunner;
import com.github.mkolisnyk.aerial.core.params.AerialSourceType;
import cucumber.api.CucumberOptions;

@CucumberOptions(
        format = {"html:target/cucumber-html-report",
                  "json:target/cucumber.json",
                  "pretty:target/cucumber-pretty.txt",
                  "usage:target/cucumber-usage.json"
                 },
        features = {"output/" },
        glue = {"com/github/mkolisnyk/aerial" },
        tags = { }
)
@Aerial(
    inputType = AerialSourceType.FILE,
    source = "src/test/resources",
    additionalParams = { "" },
    destination = "output/")
@RunWith(AerialRunner.class)
public class AerialRunnerTest {
    @AerialBeforeSuite
    public static void setUp() {
        System.out.println("setUp");
    }
    @AerialAfterSuite
    public static void tearDown() {
        System.out.println("tearDown");
    }
}
{% endhighlight %}
